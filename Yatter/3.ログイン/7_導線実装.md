# 導線実装
ログイン画面とパブリックタイムライン画面の導線実装を行います。  
アプリを起動した時の挙動を変更します。  

Yatterアプリで既にログインしていればアプリ起動時にはそのままパブリックタイムライン画面に遷移し、一度もログインしていなければログイン画面に遷移します。  

ログイン済みかどうかを判定するために`CheckLoginService`を新規作成し、`MainViewModel`でログイン状況を確認して遷移する画面を制御します。  

まずは`CheckLoginService`の実装からです。  
`CheckLoginService`はDomainServiceにあたるため、`domain/service`パッケージにinterfaceを定義し`infra/domain/service`に実装クラスを配置します。  

```Kotlin
// domain/service/CheckLoginService.kt

interface CheckLoginService {
  suspend fun execute(): Boolean
}
```

```Kotlin
// infra/domain/service/CheckLoginServiceImpl.kt

internal class CheckLoginServiceImpl(
  private val mePreferences: MePreferencese,
) : CheckLoginService {
  override suspend fun execute(): Boolean {
    return mePreferences.getUsername() != ""
  }
}
```

`CheckLoginServiceImpl`の実装が完了したら単体テストを書いてみましょう。  
今回のテストでは次の観点の確認ができると良さそうです。  

- MePreferencesに値が保存されていなければfalse
- MePreferencesに値が保存されていればtrue

<details>
<summary>CheckLoginServiceImplのテスト実装例</summary>

```Kotlin
class CheckLoginServiceImplSpec {
  private val mePreferences = mockk<MePreferences>()
  private val subject = CheckLoginServiceImpl(mePreferences)

  @Test
  fun getTrueWhenSavedUsername() = runTest {
    val username = "username"

    coEvery {
      mePreferences.getUsername()
    } returns username

    val result: Boolean = subject.execute()

    assertThat(result).isTrue()
  }

  @Test
  fun getFalseWhenUnsavedUsername() = runTest {
    val username = ""

    coEvery {
      mePreferences.getUsername()
    } returns username

    val result: Boolean = subject.execute()

    assertThat(result).isFalse()
  }
}
```

</details>

---

テストを書いて動作問題ないことを確認したら続いてViewModelの実装を行います。  

`MainActivity`が属しているパッケージに`MainViewModel.kt`ファイルを作成して、`MainViewModel`を定義します。  

```Kotlin
class MainViewModel : ViewModel()
```

`MainViewModel`ではログイン状況を確認するために引数に`CheckLoginService`を受け取ります。  

```Kotlin
class MainViewModel(
  private val checkLoginService: CheckLoginService,
) : ViewModel()
```

ログイン画面実装の際に行なったように遷移用の`SingleLiveEvent`の値を定義します。  
遷移先はログイン画面とパブリックタイムライン画面です。  

```Kotlin
private val _navigateToLogin: SingleLiveEvent<Unit> = SingleLiveEvent()
val navigateToLogin: LiveData<Unit> = _navigateToLogin

private val _navigateToPublicTimeline: SingleLiveEvent<Unit> = SingleLiveEvent()
val navigateToPublicTimeline: LiveData<Unit> = _navigateToPublicTimeline
```

遷移用の値が作成できたため、画面初期化(`onCreate`)時にログイン状況を確認して遷移用の値を流します。  

```Kotlin
fun onCreate() {
  viewModelScope.launch {
    if (checkLoginService.execute()) {
      _navigateToPublicTimeline.value = Unit
    } else {
      _navigateToLogin.value = Unit
    }
  }
}
```

`MainViewModel`のテストも書いてみましょう。    
`MainViewModel`のテストは次の観点で確認します。  

- ログイン済みであれば、パブリックタイムライン画面への遷移
- ログイン済みでなければ、ログイン画面への遷移

<details>
<summary>MainViewModelのテスト実装例</summary>

```Kotlin
class MainViewModelSpec {
  private val checkLoginService = mockk<CheckLoginService>()
  private val subject = MainViewModel(checkLoginService)

  @get:Rule
  val mainDispatcherRule = MainDispatcherRule()

  @get:Rule
  val rule: TestRule = InstantTaskExecutorRule()

  @Test
  fun navigateToPublicTimelineWhenLoggedIn() = runTest {
    coEvery {
      checkLoginService.execute()
    } returns true

    subject.onCreate()

    assertThat(subject.navigateToPublicTimeline.value).isNotNull()
    assertThat(subject.navigateToLogin.value).isNull()
  }

  @Test
  fun navigateToLoginWhenNotLoggedIn() = runTest {
    coEvery {
      checkLoginService.execute()
    } returns false

    subject.onCreate()

    assertThat(subject.navigateToLogin.value).isNotNull()
    assertThat(subject.navigateToPublicTimeline.value).isNull()
  }
}
```

</details>

---

ViewModelから遷移用の値を公開できたら今度はActivity側で購読します。  

```Kotlin
class MainActivity : AppCompatActivity() {
  private val viewModel: MainViewModel by viewModel()

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    
    ...

    viewModel.onCreate()

    viewModel.navigateToPublicTimeline.observe(this) {
      startActivity(PublicTimelineActivity.newIntent(this))
      finish()
    }

    viewModel.navigateToLogin.observe(this) {
      startActivity(LoginActivity.newIntent(this))
      finish()
    }
  }
}
```

実装できたらDIの設定も忘れずに行います。  
今回は、`CheckLoginService`と`MainViewModel`を追加したので`domainImplModule`と`viewModelModule`に追記します。  

追記できたら実際に動かしてみましょう。  
実行時にエラーになる場合は記述の仕方を見直してみたりコード例と比較してみながら原因を探してみてくだい。  

<details>
<summary>DIコード例</summary>

```Kotlin
// DomainImplModule.kt
internal val domainImplModule = module {
  ...
  factory<CheckLoginService> { CheckLoginServiceImpl(get()) }
}

// ViewModelModule.kt
```

</details>


これらの実装によりログイン状況に応じてアプリ起動時に表示される画面を分岐することができました。  
エミュレータで実際にYatterアプリを実装してみて動作を確認してみてください。  
一度ログインした後に再度ログイン画面を表示させたいときはアプリを再インストールすることでログイン画面から再度動作を確認できます。  
